<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>March Madness Archive</title>
  <link rel="icon" href="data:,">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --surface: rgba(15, 23, 42, 0.82);
      --surface-light: rgba(255, 255, 255, 0.08);
      --text: #f8fafc;
      --muted: #94a3b8;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.15);
      --border: rgba(148, 163, 184, 0.25);
      --shadow: 0 18px 40px rgba(15, 23, 42, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100dvh;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .app {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding-bottom: calc(60px + env(safe-area-inset-bottom));
      overflow: hidden;
    }

    main {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .tab-panel {
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding: 12px;
      display: none;
    }

    .tab-panel.active {
      display: flex;
      flex-direction: column;
    }

    .tab-bar {
      display: flex;
      gap: 0;
      background: rgba(20, 27, 45, 0.95);
      border-top: 1px solid rgba(148, 163, 184, 0.15);
      padding: 6px 0 calc(6px + env(safe-area-inset-bottom));
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 100;
      backdrop-filter: blur(24px);
      -webkit-backdrop-filter: blur(24px);
    }

    .tab-btn {
      flex: 1;
      background: none;
      border: none;
      color: var(--muted);
      font-size: 0.65rem;
      font-weight: 500;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px;
      padding: 4px 8px;
      border-radius: 0;
      transition: color 0.15s ease;
      cursor: pointer;
    }

    .tab-btn svg {
      width: 22px;
      height: 22px;
      stroke-width: 1.8;
    }

    .tab-btn.active {
      color: var(--accent);
    }

    .tab-btn.active svg {
      filter: drop-shadow(0 0 6px rgba(56, 189, 248, 0.5));
    }

    .panel-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .panel-card h2 {
      margin: 0 0 10px;
      font-size: 1rem;
      font-weight: 600;
    }

    .control-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
    }

    label {
      font-size: 0.8rem;
      color: var(--muted);
    }

    select, button.primary {
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.7);
      color: var(--text);
      padding: 8px 10px;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
    }

    select:focus, button.primary:focus {
      outline: none;
      border-color: var(--accent);
    }

    button.primary {
      background: linear-gradient(135deg, var(--accent), #3b82f6);
      border: none;
    }

    button.primary:active {
      opacity: 0.9;
    }

    .btn-secondary {
      background: var(--surface-light);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 0.7rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.12);
      border-color: var(--accent);
    }

    .simtab-panel {
      display: none;
    }

    .simtab-panel.active {
      display: block;
    }

    .view-toggle {
      display: flex;
      gap: 4px;
      background: rgba(15, 23, 42, 0.5);
      padding: 4px;
      border-radius: 8px;
      margin-left: auto;
    }

    .view-toggle button {
      background: none;
      border: none;
      color: var(--muted);
      font-size: 0.75rem;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
    }

    .view-toggle button.active {
      background: var(--accent-soft);
      color: var(--accent);
    }

    .bracket-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      width: 100%;
    }

    .round-column h3 {
      margin: 0 0 8px;
      font-size: 0.8rem;
      color: var(--muted);
      font-weight: 600;
    }

    .game-card {
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.15);
      padding: 8px;
      background: rgba(15, 23, 42, 0.6);
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 6px;
    }

    .game-card.highlight {
      border-color: rgba(56, 189, 248, 0.5);
    }

    .team-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.75rem;
    }

    .team-row.winner {
      color: var(--accent);
      font-weight: 600;
    }

    .team-meta {
      font-size: 0.65rem;
      color: var(--muted);
      margin-top: 2px;
    }

    /* Bracket Tree View - Real bracket with lines */
    .bracket-tree {
      display: none;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      flex: 1;
    }

    .bracket-tree.active {
      display: block;
    }

    .bracket-container {
      display: flex;
      padding: 12px;
      min-width: max-content;
      gap: 0;
    }

    .bracket-round {
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .bracket-round-header {
      text-align: center;
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--accent);
      padding: 4px 8px 10px;
      position: sticky;
      top: 0;
      background: var(--bg);
      z-index: 3;
      min-width: 120px;
    }

    .bracket-games {
      display: flex;
      flex-direction: column;
      justify-content: space-around;
      flex: 1;
      position: relative;
    }

    .bracket-game {
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid var(--border);
      border-radius: 6px;
      margin: 4px 0;
      font-size: 0.68rem;
      position: relative;
      min-width: 110px;
      overflow: hidden;
    }

    .bracket-game.champion {
      border-color: var(--accent);
      box-shadow: 0 0 12px rgba(56, 189, 248, 0.3);
    }

    .bracket-team {
      display: flex;
      align-items: center;
      padding: 5px 8px;
      gap: 6px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.1);
      transition: background 0.15s;
    }

    .bracket-team:last-child {
      border-bottom: none;
    }

    .bracket-team.winner {
      background: rgba(56, 189, 248, 0.12);
    }

    .bracket-team.winner .bracket-team-name {
      color: var(--accent);
      font-weight: 600;
    }

    .bracket-seed {
      color: var(--muted);
      font-size: 0.6rem;
      min-width: 14px;
      text-align: center;
    }

    .bracket-team-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text);
    }

    .bracket-score {
      color: var(--muted);
      font-size: 0.6rem;
      min-width: 16px;
      text-align: right;
    }

    .team-logo {
      width: 20px;
      height: 20px;
      object-fit: contain;
      border-radius: 3px;
      flex-shrink: 0;
    }

    .team-logo.small {
      width: 16px;
      height: 16px;
    }

    .team-logo.large {
      width: 32px;
      height: 32px;
    }

    .modal-team-logo {
      width: 48px;
      height: 48px;
      object-fit: contain;
      border-radius: 6px;
    }

    /* Connector lines */
    .bracket-connector {
      width: 20px;
      display: flex;
      flex-direction: column;
      justify-content: space-around;
      position: relative;
    }

    .connector-line {
      position: absolute;
      background: var(--border);
    }

    .connector-h {
      height: 1px;
      width: 10px;
    }

    .connector-v {
      width: 1px;
    }

    /* List view styling */
    .bracket-list {
      display: none;
      overflow: auto;
      flex: 1;
    }

    .bracket-list.active {
      display: block;
    }

    .stat-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.75rem;
    }

    .stat-table th, .stat-table td {
      padding: 8px 6px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.12);
      text-align: left;
    }

    .stat-table th {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .stat-table th.sortable {
      cursor: pointer;
      user-select: none;
      color: var(--muted);
    }

    .stat-table th.sortable::after {
      content: '';
      margin-left: 2px;
    }

    .stat-table th.sortable.active-asc::after {
      content: '‚Üë';
    }

    .stat-table th.sortable.active-desc::after {
      content: '‚Üì';
    }

    .stat-table tbody tr:active {
      background: rgba(56, 189, 248, 0.1);
    }

    .clickable-row {
      cursor: pointer;
    }

    .win-bar {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .win-bar-fill {
      height: 4px;
      background: var(--accent);
      border-radius: 2px;
      min-width: 2px;
    }

    .subtab-bar {
      display: flex;
      gap: 4px;
      background: rgba(15, 23, 42, 0.5);
      padding: 4px;
      border-radius: 8px;
      margin-bottom: 12px;
    }

    .subtab-btn {
      flex: 1;
      border: none;
      background: transparent;
      color: var(--muted);
      font-weight: 500;
      padding: 8px 6px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.75rem;
    }

    .subtab-btn.active {
      background: var(--accent-soft);
      color: var(--accent);
    }

    .subtab-panel {
      display: none;
      animation: fadeIn 0.3s ease;
    }

    .subtab-panel.active {
      display: block;
    }

    .tag-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(56, 189, 248, 0.12);
      border: 1px solid rgba(56, 189, 248, 0.25);
      color: var(--accent);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.8rem;
      margin-right: 8px;
    }

    .empty-state {
      padding: 24px;
      border-radius: 16px;
      border: 1px dashed rgba(148, 163, 184, 0.3);
      text-align: center;
      color: var(--muted);
    }

    .seed-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 8px;
    }

    .seed-card {
      padding: 10px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.15);
      background: rgba(15, 23, 42, 0.6);
    }

    .seed-card h4 {
      margin: 0 0 8px;
      font-size: 0.8rem;
    }

    .muted {
      color: var(--muted);
      font-size: 0.8rem;
    }

    .sim-output {
      margin-top: 12px;
    }

    .loading {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .loading span {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 3px solid rgba(56, 189, 248, 0.35);
      border-top-color: var(--accent);
      animation: spin 0.9s linear infinite;
    }

    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      display: flex;
      justify-content: center;
      align-items: flex-end;
      padding: 0;
      z-index: 200;
    }

    .modal-overlay[hidden] {
      display: none;
    }

    .modal-content {
      width: 100%;
      max-height: 85vh;
      overflow-y: auto;
      background: linear-gradient(180deg, rgba(30, 41, 59, 0.98) 0%, rgba(15, 23, 42, 0.98) 100%);
      border-radius: 24px 24px 0 0;
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-bottom: none;
      box-shadow: 0 -12px 60px rgba(0, 0, 0, 0.45);
      padding: 0;
      color: var(--text);
      animation: slideUp 0.25s ease-out;
    }

    @keyframes slideUp {
      from { transform: translateY(100%); }
      to { transform: translateY(0); }
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      padding: 20px 20px 16px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.15);
      position: sticky;
      top: 0;
      background: rgba(30, 41, 59, 0.98);
      z-index: 1;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 1.15rem;
      font-weight: 600;
    }

    .modal-subtitle {
      font-size: 0.8rem;
      color: var(--muted);
      margin-top: 2px;
    }

    .modal-close {
      background: var(--surface-light);
      border: none;
      color: var(--muted);
      font-size: 1rem;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s, color 0.15s;
    }

    .modal-close:hover {
      background: rgba(255, 255, 255, 0.15);
      color: var(--accent);
    }

    .modal-stats-row {
      display: flex;
      gap: 8px;
      padding: 16px 20px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      background: rgba(15, 23, 42, 0.4);
    }

    .modal-stat {
      flex: 1;
      min-width: 70px;
      text-align: center;
      padding: 12px 8px;
      background: rgba(15, 23, 42, 0.6);
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.1);
    }

    .modal-stat-value {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--accent);
    }

    .modal-stat-label {
      font-size: 0.65rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.03em;
      margin-top: 2px;
    }

    .modal-body {
      padding: 16px 20px 24px;
    }

    .modal-section-title {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.04em;
      margin: 0 0 12px;
    }

    .game-history-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .game-history-item {
      border: 1px solid rgba(148, 163, 184, 0.12);
      border-radius: 12px;
      padding: 12px 14px;
      background: rgba(15, 23, 42, 0.5);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .game-history-item.win {
      border-left: 3px solid #22c55e;
    }

    .game-history-item.loss {
      border-left: 3px solid #ef4444;
    }

    .game-history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .game-history-year {
      font-weight: 600;
      color: var(--accent);
      font-size: 0.8rem;
    }

    .game-history-round {
      font-size: 0.7rem;
      color: var(--muted);
      background: var(--surface-light);
      padding: 2px 8px;
      border-radius: 10px;
    }

    .game-history-matchup {
      font-size: 0.8rem;
      color: var(--text);
    }

    .game-history-detail {
      font-size: 0.7rem;
      color: var(--muted);
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @media (max-width: 640px) {
      .modal-content {
        max-height: 90dvh;
        max-height: 90vh;
        padding: 16px;
        border-radius: 16px;
      }

      .control-row {
        flex-direction: column;
        align-items: stretch;
      }

      .control-row label {
        margin-bottom: -4px;
      }
    }

    @media (max-width: 820px) {
      .bracket-grid {
        display: flex;
        overflow-x: auto;
        gap: 12px;
        scroll-snap-type: x mandatory;
        -webkit-overflow-scrolling: touch;
      }

      .bracket-grid::-webkit-scrollbar {
        display: none;
      }

      .round-column {
        flex: 0 0 160px;
        scroll-snap-align: start;
      }
    }
  </style>
</head>
<body>
  <div class="app" role="application">
    <main>
      <section id="tab-brackets" class="tab-panel active" aria-labelledby="nav-brackets">
        <div class="panel-card">
          <div class="control-row">
            <label for="yearSelect">Year</label>
            <select id="yearSelect" aria-label="Select tournament year"></select>
            <div class="view-toggle" id="bracketViewToggle">
              <button data-view="tree" class="active">Bracket</button>
              <button data-view="list">List</button>
            </div>
          </div>
          <div id="bracketSummary" class="muted" style="font-size:0.8rem;"></div>
        </div>

        <div class="panel-card" style="flex:1; overflow:hidden; display:flex; flex-direction:column;">
          <div id="bracketTreeView" class="bracket-tree active"></div>
          <div id="bracketListView" class="bracket-list"></div>
        </div>
      </section>

      <section id="tab-insights" class="tab-panel" aria-labelledby="nav-insights">
        <div class="panel-card" style="flex:1; display:flex; flex-direction:column; overflow:hidden;">
          <div class="subtab-bar" role="tablist">
            <button class="subtab-btn active" data-subtab="team-history" aria-selected="true">Teams</button>
            <button class="subtab-btn" data-subtab="seed-rounds" aria-selected="false">Seeds</button>
            <button class="subtab-btn" data-subtab="seed-matchups" aria-selected="false">Matchups</button>
          </div>

          <div id="subtab-team-history" class="subtab-panel active" role="tabpanel" style="flex:1; overflow:auto;">
            <div class="muted" id="teamHistorySummary" style="font-size:0.75rem; margin-bottom:8px;"></div>
            <table class="stat-table" aria-describedby="teamHistorySummary" data-team-table="true">
              <thead>
                <tr>
                  <th scope="col" class="sortable" data-sort="team">Team</th>
                  <th scope="col" class="sortable" data-sort="titles">üèÜ</th>
                  <th scope="col" class="sortable" data-sort="wins">W</th>
                  <th scope="col" class="sortable" data-sort="losses">L</th>
                  <th scope="col" class="sortable" data-sort="winPct">%</th>
                </tr>
              </thead>
              <tbody id="teamHistoryTable"></tbody>
            </table>
          </div>

          <div id="subtab-seed-rounds" class="subtab-panel" role="tabpanel" style="flex:1; overflow:auto;">
            <div id="seedRoundGrid" class="seed-grid"></div>
          </div>

          <div id="subtab-seed-matchups" class="subtab-panel" role="tabpanel" style="flex:1; overflow:auto;">
            <table class="stat-table">
              <thead>
                <tr>
                  <th scope="col">Matchup</th>
                  <th scope="col">G</th>
                  <th scope="col">Low%</th>
                  <th scope="col">High%</th>
                </tr>
              </thead>
              <tbody id="seedMatchupTable"></tbody>
            </table>
          </div>
        </div>
      </section>

      <section id="tab-sim" class="tab-panel" aria-labelledby="nav-sim">
        <div class="panel-card">
          <div class="subtab-bar" role="tablist" style="margin-bottom:8px;">
            <button class="subtab-btn active" data-simtab="single" aria-selected="true">Single Year</button>
            <button class="subtab-btn" data-simtab="batch" aria-selected="false">All Years</button>
            <button class="subtab-btn" data-simtab="custom" aria-selected="false">Custom</button>
          </div>

          <div id="simtab-single" class="simtab-panel active">
            <div class="control-row">
              <label for="simYearSelect">Year</label>
              <select id="simYearSelect" aria-label="Select a bracket for simulation"></select>
              <label for="simModeSelect">Mode</label>
              <select id="simModeSelect" aria-label="Select simulation mode">
                <option value="seed-record">Seed record</option>
                <option value="random">Random</option>
                <option value="legacy">Legacy</option>
                <option value="team-win-pct">Win %</option>
                <option value="team-total-wins">Total W</option>
                <option value="team-titles">Titles</option>
                <option value="seed-weighted">Weighted</option>
              </select>
              <button class="primary" id="simulateBtn">Run</button>
            </div>
          </div>

          <div id="simtab-batch" class="simtab-panel" style="display:none;">
            <div class="control-row">
              <label for="batchModeSelect">Mode</label>
              <select id="batchModeSelect" aria-label="Select batch simulation mode">
                <option value="seed-record">Seed record</option>
                <option value="random">Random</option>
                <option value="legacy">Legacy</option>
                <option value="team-win-pct">Win %</option>
                <option value="team-total-wins">Total W</option>
                <option value="team-titles">Titles</option>
                <option value="seed-weighted">Weighted</option>
              </select>
              <button class="primary" id="batchSimBtn">Run All Years</button>
            </div>
            <div id="batchResults" style="margin-top:10px; font-size:0.75rem; max-height:150px; overflow-y:auto;"></div>
          </div>

          <div id="simtab-custom" class="simtab-panel" style="display:none;">
            <div class="control-row" style="margin-bottom:8px;">
              <label for="customModeSelect">Mode</label>
              <select id="customModeSelect" aria-label="Select custom simulation mode">
                <option value="seed-record">Seed record</option>
                <option value="random">Random</option>
                <option value="legacy">Legacy</option>
                <option value="team-win-pct">Win %</option>
                <option value="team-total-wins">Total W</option>
                <option value="team-titles">Titles</option>
                <option value="seed-weighted">Weighted</option>
              </select>
              <button class="primary" id="runCustomBtn">Run</button>
            </div>
            <textarea id="customTeams" placeholder="64 teams, one per line (seeded 1-16 in each region)..." style="width:100%; height:100px; background:rgba(15,23,42,0.7); color:var(--text); border:1px solid var(--border); border-radius:6px; padding:8px; font-size:0.75rem; font-family:inherit; resize:none;"></textarea>
            <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap;">
              <button class="btn-secondary" id="fillDummyBtn">Dummy Teams</button>
              <button class="btn-secondary" id="scrambleTeamsBtn">Random Historical</button>
              <button class="btn-secondary" id="loadYearBtn">Load Year Field</button>
              <button class="btn-secondary" id="clearCustomBtn">Clear</button>
            </div>
            <div id="customLoadRow" style="margin-top:6px; display:none;">
              <select id="loadYearSelect" style="background:var(--surface-light); color:var(--text); border:1px solid var(--border); border-radius:4px; padding:4px 8px; font-size:0.7rem;"></select>
              <button class="btn-secondary" id="confirmLoadYearBtn" style="margin-left:4px;">Load</button>
            </div>
          </div>
        </div>

        <div class="panel-card" style="flex:1; overflow:hidden; display:flex; flex-direction:column;">
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
            <div id="simStats" class="tag-pill" style="display:none; font-size:0.7rem; padding:4px 8px;"></div>
            <div id="simSummary" class="muted" style="font-size:0.8rem;"></div>
            <div class="view-toggle" id="simViewToggle" style="margin-left:auto;">
              <button data-view="tree" class="active">Bracket</button>
              <button data-view="list">List</button>
            </div>
          </div>
          <div id="simTreeView" class="bracket-tree active"></div>
          <div id="simListView" class="bracket-list"></div>
        </div>
      </section>
    </main>
  </div>

  <nav class="tab-bar" role="tablist">
    <button class="tab-btn active" id="nav-brackets" data-tab="brackets" aria-controls="tab-brackets" aria-selected="true">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
        <path d="M3 5h4v4H3z"/><path d="M3 15h4v4H3z"/><path d="M7 7h4v0"/><path d="M7 17h4v0"/><path d="M11 7v10"/><path d="M11 12h4"/><path d="M15 12v0h4v0"/>
      </svg>
      Bracket
    </button>
    <button class="tab-btn" id="nav-insights" data-tab="insights" aria-controls="tab-insights" aria-selected="false">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
        <path d="M18 20V10"/><path d="M12 20V4"/><path d="M6 20v-6"/>
      </svg>
      Stats
    </button>
    <button class="tab-btn" id="nav-sim" data-tab="sim" aria-controls="tab-sim" aria-selected="false">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="5 3 19 12 5 21 5 3"/>
      </svg>
      Simulate
    </button>
  </nav>

    <div id="teamModal" class="modal-overlay" hidden>
      <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="teamModalTitle">
        <div class="modal-header">
          <div>
            <h3 id="teamModalTitle"></h3>
            <div id="teamModalSubtitle" class="modal-subtitle"></div>
          </div>
          <button class="modal-close" id="teamModalClose" aria-label="Close team history dialog">&times;</button>
        </div>
        <div id="teamModalStats" class="modal-stats-row"></div>
        <div class="modal-body" id="teamModalBody">
          <h4 class="modal-section-title">Tournament History</h4>
          <ul id="teamModalList" class="game-history-list"></ul>
        </div>
      </div>
    </div>

  <template id="loadingTemplate">
    <div class="loading" role="status">
      <span aria-hidden="true"></span>
      <strong>Loading tournaments‚Ä¶</strong>
    </div>
  </template>

  <script>
    const YEAR_START = 1985;
    const YEAR_END = 2025;
    const ROUND_SEQUENCE = ['round1', 'round2', 'sweet16', 'elite8', 'finalFour', 'championship'];

    // Team name aliases - maps variations to canonical names
    const TEAM_ALIASES = {
      'Connecticut': 'UConn',
      'UNC': 'North Carolina',
      'Pitt': 'Pittsburgh',
      'Ole Miss': 'Mississippi',
    };

    function normalizeTeamName(name) {
      if (!name) return name;
      return TEAM_ALIASES[name] || name;
    }

    const state = {
      tournaments: new Map(),
      aggregated: null,
      currentYear: null,
      loaded: false,
      teamSort: { key: 'titles', direction: 'desc' },
      bracketView: 'tree',
      simView: 'tree',
      allHistoricalTeams: [], // For random team scrambler
      teamLogos: {}, // Loaded from team-logos.json
    };

    document.addEventListener('DOMContentLoaded', () => {
      setupTabs();
      setupSubtabs();
      setupSimTabs();
      setupViewToggles();
      setupTeamTableInteractions();
      setupModalControls();
      setupSimControls();
      bootstrap();
    });

    async function bootstrap() {
      renderLoading();
      await loadTeamLogos();
      await loadAllTournaments();
      populateYearSelectors();
      computeAggregatedStats();
      hydrateInsights();
      state.loaded = true;
      const defaultYear = state.tournaments.size ? Math.max(...state.tournaments.keys()) : YEAR_END;
      setActiveYear(defaultYear);
    }

    async function loadTeamLogos() {
      try {
        const response = await fetch('./team-logos.json');
        if (response.ok) {
          const data = await response.json();
          state.teamLogos = data.teamLogos || {};
        }
      } catch (err) {
        console.warn('Failed to load team logos:', err);
      }
    }

    function getTeamLogoUrl(teamName) {
      if (!teamName || !state.teamLogos) return null;
      // Try normalized name first
      const normalized = normalizeTeamName(teamName);
      return state.teamLogos[normalized] || state.teamLogos[teamName] || null;
    }

    function setupTabs() {
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          if (btn.classList.contains('active')) return;
          document.querySelectorAll('.tab-btn').forEach(b => {
            b.classList.toggle('active', b === btn);
            b.setAttribute('aria-selected', b === btn ? 'true' : 'false');
          });
          document.querySelectorAll('.tab-panel').forEach(panel => {
            panel.classList.toggle('active', panel.id === `tab-${btn.dataset.tab}`);
          });
        });
      });
    }

    function setupSubtabs() {
      document.querySelectorAll('.subtab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const target = btn.dataset.subtab;
          if (!target) return; // Skip if no subtab data attribute (might be simtab)
          document.querySelectorAll('.subtab-btn[data-subtab]').forEach(b => {
            const isActive = b === btn;
            b.classList.toggle('active', isActive);
            b.setAttribute('aria-selected', isActive ? 'true' : 'false');
          });
          document.querySelectorAll('.subtab-panel').forEach(panel => {
            panel.classList.toggle('active', panel.id === `subtab-${target}`);
          });
        });
      });
    }

    function setupSimTabs() {
      document.querySelectorAll('[data-simtab]').forEach(btn => {
        btn.addEventListener('click', () => {
          const target = btn.dataset.simtab;
          document.querySelectorAll('[data-simtab]').forEach(b => {
            const isActive = b === btn;
            b.classList.toggle('active', isActive);
            b.setAttribute('aria-selected', isActive ? 'true' : 'false');
          });
          document.querySelectorAll('.simtab-panel').forEach(panel => {
            const isTarget = panel.id === `simtab-${target}`;
            panel.style.display = isTarget ? 'block' : 'none';
            panel.classList.toggle('active', isTarget);
          });
        });
      });
    }

    function setupSimControls() {
      // Single year simulate
      document.getElementById('simulateBtn')?.addEventListener('click', runSimulation);

      // Batch simulation
      document.getElementById('batchSimBtn')?.addEventListener('click', runBatchSimulation);

      // Custom field controls
      document.getElementById('runCustomBtn')?.addEventListener('click', runCustomSimulation);
      document.getElementById('fillDummyBtn')?.addEventListener('click', fillDummyTeams);
      document.getElementById('scrambleTeamsBtn')?.addEventListener('click', scrambleRandomTeams);
      document.getElementById('clearCustomBtn')?.addEventListener('click', () => {
        document.getElementById('customTeams').value = '';
      });
      
      // Load year field
      document.getElementById('loadYearBtn')?.addEventListener('click', () => {
        const loadRow = document.getElementById('customLoadRow');
        loadRow.style.display = loadRow.style.display === 'none' ? 'flex' : 'none';
      });
      document.getElementById('confirmLoadYearBtn')?.addEventListener('click', loadYearField);
    }

    function setupViewToggles() {
      // Bracket tab view toggle
      document.querySelectorAll('#bracketViewToggle button').forEach(btn => {
        btn.addEventListener('click', () => {
          const view = btn.dataset.view;
          state.bracketView = view;
          document.querySelectorAll('#bracketViewToggle button').forEach(b => b.classList.toggle('active', b === btn));
          document.getElementById('bracketListView').classList.toggle('active', view === 'list');
          document.getElementById('bracketTreeView').classList.toggle('active', view === 'tree');
        });
      });

      // Sim tab view toggle
      document.querySelectorAll('#simViewToggle button').forEach(btn => {
        btn.addEventListener('click', () => {
          const view = btn.dataset.view;
          state.simView = view;
          document.querySelectorAll('#simViewToggle button').forEach(b => b.classList.toggle('active', b === btn));
          document.getElementById('simListView').classList.toggle('active', view === 'list');
          document.getElementById('simTreeView').classList.toggle('active', view === 'tree');
        });
      });
    }

    function renderLoading() {
      const bracketTree = document.getElementById('bracketTreeView');
      const simTree = document.getElementById('simTreeView');
      const template = document.getElementById('loadingTemplate');
      bracketTree.innerHTML = '';
      bracketTree.appendChild(template.content.cloneNode(true));
      simTree.innerHTML = '';
      simTree.appendChild(template.content.cloneNode(true));
    }

    async function loadAllTournaments() {
      const fetches = [];
      for (let year = YEAR_START; year <= YEAR_END; year++) {
        if (year === 2020) {
          console.info('Skipping 2020 tournament data (season canceled).');
          continue;
        }
        const url = `json/tournament-${year}.json`;
        fetches.push(fetch(url)
          .then(resp => {
            if (!resp.ok) throw new Error(`Missing dataset ${year}`);
            return resp.json().then(data => state.tournaments.set(year, data));
          })
          .catch(() => {
            console.warn(`Tournament data not found for ${year}, skipping.`);
          }));
      }
      await Promise.all(fetches);
    }

    function populateYearSelectors() {
      const yearOptions = Array.from(state.tournaments.keys()).sort((a, b) => b - a);
      const yearSelect = document.getElementById('yearSelect');
      const simYearSelect = document.getElementById('simYearSelect');
      const loadYearSelect = document.getElementById('loadYearSelect');
      yearOptions.forEach(year => {
        const option = new Option(year, year);
        yearSelect.add(option.cloneNode(true));
        simYearSelect.add(option.cloneNode(true));
        if (loadYearSelect) loadYearSelect.add(option.cloneNode(true));
      });
      yearSelect.addEventListener('change', event => setActiveYear(Number(event.target.value)));
    }

    function fillDummyTeams() {
      const dummies = Array.from({ length: 64 }, (_, i) => `Team ${i + 1}`);
      document.getElementById('customTeams').value = dummies.join('\n');
    }

    function scrambleRandomTeams() {
      if (state.allHistoricalTeams.length < 64) {
        alert('Historical team data not yet loaded');
        return;
      }
      // Shuffle and pick 64 unique teams
      const shuffled = [...state.allHistoricalTeams].sort(() => Math.random() - 0.5);
      const uniqueTeams = [...new Set(shuffled)].slice(0, 64);
      if (uniqueTeams.length < 64) {
        // Fill with duplicates if needed
        while (uniqueTeams.length < 64) {
          uniqueTeams.push(shuffled[uniqueTeams.length % shuffled.length]);
        }
      }
      document.getElementById('customTeams').value = uniqueTeams.join('\n');
    }

    function loadYearField() {
      const year = Number(document.getElementById('loadYearSelect').value);
      if (!state.tournaments.has(year)) return;
      const data = state.tournaments.get(year);
      const teams = [];
      // Extract teams from round1 in bracket order
      (data.rounds.round1 || []).forEach(game => {
        teams.push(game.team1 || 'TBD');
        teams.push(game.team2 || 'TBD');
      });
      document.getElementById('customTeams').value = teams.join('\n');
      document.getElementById('customLoadRow').style.display = 'none';
    }

    function runCustomSimulation() {
      if (!state.loaded || !state.aggregated) {
        alert('Datasets still loading. Try again in a moment.');
        return;
      }
      const customInput = document.getElementById('customTeams').value.trim();
      if (!customInput) {
        alert('Please enter teams or use the fill options.');
        return;
      }
      const teams = customInput.split('\n').map(t => t.trim()).filter(Boolean);
      if (teams.length < 64) {
        alert(`Please provide at least 64 teams (currently ${teams.length}).`);
        return;
      }
      const mode = document.getElementById('customModeSelect').value;
      const baseRounds = { round1: buildCustomRound1(teams.slice(0, 64)) };
      const bracket = simulateBracket(baseRounds, mode);
      renderSimulation(bracket, mode, null);
    }

    function runBatchSimulation() {
      if (!state.loaded || !state.aggregated) {
        alert('Datasets still loading. Try again in a moment.');
        return;
      }
      const mode = document.getElementById('batchModeSelect').value;
      const resultsDiv = document.getElementById('batchResults');
      resultsDiv.innerHTML = '<div class="muted">Running simulations...</div>';
      
      const years = Array.from(state.tournaments.keys()).sort((a, b) => b - a);
      const results = [];
      let totalAccuracy = 0;
      let count = 0;
      
      years.forEach(year => {
        const data = state.tournaments.get(year);
        if (!data?.rounds?.round1) return;
        const bracket = simulateBracket(data.rounds, mode);
        const accuracy = calculateBracketAccuracy(bracket, data.rounds);
        if (accuracy !== null) {
          totalAccuracy += accuracy;
          count++;
        }
        const correct = bracket.championship?.winner === data.champion;
        results.push({ year, accuracy, champion: bracket.championship?.winner, actual: data.champion, correct });
      });
      
      const avgAccuracy = count > 0 ? (totalAccuracy / count).toFixed(1) : '0';
      const correctChamps = results.filter(r => r.correct).length;
      
      let html = `<div style="margin-bottom:8px;"><strong>Avg Accuracy:</strong> ${avgAccuracy}% ¬∑ <strong>Correct Champs:</strong> ${correctChamps}/${results.length}</div>`;
      html += '<div style="display:grid; grid-template-columns:repeat(auto-fill, minmax(120px, 1fr)); gap:4px;">';
      results.forEach(r => {
        const color = r.correct ? '#22c55e' : 'var(--muted)';
        html += `<div style="padding:4px 6px; background:var(--surface-light); border-radius:6px; font-size:0.7rem;">
          <span style="color:${color};">${r.year}</span>: ${r.accuracy ?? '?'}% ${r.correct ? '‚úì' : ''}
        </div>`;
      });
      html += '</div>';
      resultsDiv.innerHTML = html;
    }

    function setActiveYear(year) {
      if (!state.tournaments.has(year)) return;
      state.currentYear = year;
      document.getElementById('yearSelect').value = year;
      document.getElementById('simYearSelect').value = year;
      renderBracketTree(year);
      renderBracketList(year);
      renderBracketSummary(year);
    }

    function renderBracketTree(year) {
      const data = state.tournaments.get(year);
      if (!data) return;
      const container = document.getElementById('bracketTreeView');
      container.innerHTML = '';
      container.appendChild(createBracketTreeElement(data.rounds));
    }

    function renderBracketList(year) {
      const data = state.tournaments.get(year);
      if (!data) return;
      const container = document.getElementById('bracketListView');
      container.innerHTML = '';
      
      const roundOrder = [
        { key: 'round1', label: 'Round of 64' },
        { key: 'round2', label: 'Round of 32' },
        { key: 'sweet16', label: 'Sweet 16' },
        { key: 'elite8', label: 'Elite Eight' },
        { key: 'finalFour', label: 'Final Four' },
        { key: 'championship', label: 'Championship' },
      ];
      
      roundOrder.forEach(round => {
        const section = document.createElement('div');
        section.style.marginBottom = '16px';
        
        const header = document.createElement('h3');
        header.style.cssText = 'font-size:0.85rem; color:var(--accent); margin:0 0 8px; padding:0 4px;';
        header.textContent = round.label;
        section.appendChild(header);
        
        const gamesContainer = document.createElement('div');
        gamesContainer.style.cssText = 'display:grid; grid-template-columns:repeat(auto-fill, minmax(150px, 1fr)); gap:8px;';
        
        if (round.key === 'championship') {
          const final = data.rounds.championship;
          if (final) gamesContainer.appendChild(renderListGame(final, true));
        } else {
          (data.rounds[round.key] || []).forEach(game => {
            gamesContainer.appendChild(renderListGame(game, round.key === 'finalFour'));
          });
        }
        
        section.appendChild(gamesContainer);
        container.appendChild(section);
      });
    }

    function createBracketTreeElement(rounds, isChampion = false) {
      const wrapper = document.createElement('div');
      wrapper.className = 'bracket-container';
      
      const roundOrder = [
        { key: 'round1', label: 'R64', games: 32 },
        { key: 'round2', label: 'R32', games: 16 },
        { key: 'sweet16', label: 'Sweet 16', games: 8 },
        { key: 'elite8', label: 'Elite 8', games: 4 },
        { key: 'finalFour', label: 'Final 4', games: 2 },
        { key: 'championship', label: 'Champion', games: 1 },
      ];
      
      roundOrder.forEach((round, roundIndex) => {
        // Add round column
        const col = document.createElement('div');
        col.className = 'bracket-round';
        
        const header = document.createElement('div');
        header.className = 'bracket-round-header';
        header.textContent = round.label;
        col.appendChild(header);
        
        const gamesDiv = document.createElement('div');
        gamesDiv.className = 'bracket-games';
        
        if (round.key === 'championship') {
          const final = rounds.championship;
          if (final) {
            gamesDiv.appendChild(createBracketGame(final, true));
          }
        } else {
          const games = rounds[round.key] || [];
          games.forEach(game => {
            gamesDiv.appendChild(createBracketGame(game, false));
          });
        }
        
        col.appendChild(gamesDiv);
        wrapper.appendChild(col);
        
        // Add connector column between rounds (except after last)
        if (roundIndex < roundOrder.length - 1) {
          const connector = document.createElement('div');
          connector.className = 'bracket-connector';
          wrapper.appendChild(connector);
        }
      });
      
      return wrapper;
    }

    function createBracketGame(game, isChampionship = false) {
      const card = document.createElement('div');
      card.className = 'bracket-game' + (isChampionship ? ' champion' : '');
      
      const createTeamDiv = (team, seed, score, isWinner) => {
        const div = document.createElement('div');
        div.className = 'bracket-team' + (isWinner ? ' winner' : '');
        
        const logoUrl = getTeamLogoUrl(team);
        const logoHtml = logoUrl ? `<img src="${logoUrl}" alt="${team}" class="team-logo" onerror="this.style.display='none'">` : '';
        
        div.innerHTML = `
          <span class="bracket-seed">${seed ?? ''}</span>
          ${logoHtml}
          <span class="bracket-team-name">${team || 'TBD'}</span>
          <span class="bracket-score">${score ?? ''}</span>
        `;
        return div;
      };
      
      card.appendChild(createTeamDiv(game.team1, game.seed1, game.score1, game.winner === game.team1));
      card.appendChild(createTeamDiv(game.team2, game.seed2, game.score2, game.winner === game.team2));
      return card;
    }

    function renderListGame(game, highlight = false) {
      const card = document.createElement('div');
      card.className = 'game-card' + (highlight ? ' highlight' : '');
      
      const teams = [
        { team: game.team1, seed: game.seed1, score: game.score1 },
        { team: game.team2, seed: game.seed2, score: game.score2 },
      ];
      
      teams.forEach(entry => {
        const row = document.createElement('div');
        row.className = 'team-row' + (entry.team === game.winner ? ' winner' : '');
        
        const logoUrl = getTeamLogoUrl(entry.team);
        const logoHtml = logoUrl ? `<img src="${logoUrl}" alt="${entry.team}" class="team-logo small" onerror="this.style.display='none'">` : '';
        
        row.innerHTML = `<span>${logoHtml}<span>${entry.seed ?? '?'} ${entry.team || 'TBD'}</span></span><span>${entry.score ?? ''}</span>`;
        card.appendChild(row);
      });
      
      return card;
    }

    function renderGameCard(game, highlight = false) {
      return renderListGame(game, highlight);
    }

    function renderChampionshipCard(final) {
      if (!final) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.textContent = 'No data';
        return empty;
      }
      return renderListGame(final, true);
    }

    function renderBracketSummary(year) {
      const data = state.tournaments.get(year);
      const summary = document.getElementById('bracketSummary');
      summary.innerHTML = `üèÜ ${data.champion} (${data.championSeed}) def. ${data.runnerUp} (${data.runnerUpSeed})`;
    }

    function resolveWinnerSeed(game) {
      if (!game || !game.winner) return null;
      if (game.winner === game.team1) return game.seed1 ?? null;
      if (game.winner === game.team2) return game.seed2 ?? null;
      return null;
    }

    function computeAggregatedStats() {
      const teamMap = new Map();
      const seedRoundMap = new Map();
      const matchupMap = new Map();
      const roundKeys = ['round1', 'round2', 'sweet16', 'elite8', 'finalFour'];

      const tournaments = Array.from(state.tournaments.values());
      tournaments.forEach(tournament => {
        const championStats = ensureTeam(teamMap, tournament.champion);
        if (championStats) championStats.titles += 1;
        const runnerStats = ensureTeam(teamMap, tournament.runnerUp);
        if (runnerStats) runnerStats.runnerUp += 1;
        (tournament.finalFour || []).forEach(entry => {
          const teamStats = ensureTeam(teamMap, entry.team);
          if (teamStats) teamStats.finalFour += 1;
        });

        // Track processed game signatures per tournament to avoid counting duplicated/corrupt entries
        const processedGames = new Set();
        roundKeys.forEach(roundKey => {
          const playedThisRound = new Set();
          (tournament.rounds[roundKey] || []).forEach(game => {
            if (!game || typeof game !== 'object') return;
            // Build a stable signature for the game to detect duplicates
            const sig = `${roundKey}|${game.seed1 ?? ''}|${game.seed2 ?? ''}|${game.team1 ?? ''}|${game.team2 ?? ''}|${game.score1 ?? ''}|${game.score2 ?? ''}`;
            if (processedGames.has(sig)) return; // skip exact duplicate entries
            processedGames.add(sig);

            // Check for placeholder/duplicate teams in the same round
            if (playedThisRound.has(game.team1) || playedThisRound.has(game.team2)) {
              return; // Skip duplicate matchups in same round (placeholder data)
            }
            if (!game.team1 || !game.team2 || game.team1 === game.team2) return;
            
            playedThisRound.add(game.team1);
            playedThisRound.add(game.team2);
            
            registerRoundGame(seedRoundMap, teamMap, roundKey, game, tournament.year);
            registerMatchup(matchupMap, game);
          });
        });
        
        const final = tournament.rounds.championship;
        if (final && final.team1 && final.team2 && final.team1 !== final.team2) {
          registerChampionship(seedRoundMap, matchupMap, teamMap, final, tournament.year);
        }
      });

      state.aggregated = {
        teamHistory: teamMap,
        seedRounds: seedRoundMap,
        matchups: matchupMap,
        totalSeasons: tournaments.length,
      };
      
      // Build historical teams list for random scrambler
      state.allHistoricalTeams = Array.from(teamMap.keys());
    }

    function ensureTeam(map, teamName) {
      if (!teamName) return null;
      const normalized = normalizeTeamName(teamName);
      if (!map.has(normalized)) {
        map.set(normalized, { titles: 0, runnerUp: 0, finalFour: 0, wins: 0, losses: 0, games: [] });
      }
      return map.get(normalized);
    }

    function registerRoundGame(seedRoundMap, teamMap, roundKey, game, year) {
      if (!game) return;
      updateSeedRound(seedRoundMap, roundKey, game.seed1, game.winner === game.team1);
      updateSeedRound(seedRoundMap, roundKey, game.seed2, game.winner === game.team2);
      recordTeamResult(teamMap, year, roundKey, game);
    }

    function registerChampionship(seedRoundMap, matchupMap, teamMap, final, year) {
      if (!final) return;
      registerRoundGame(seedRoundMap, teamMap, 'championship', {
        team1: final.team1,
        seed1: final.seed1,
        team2: final.team2,
        seed2: final.seed2,
        winner: final.winner,
        score1: final.score1,
        score2: final.score2,
      }, year);
      registerMatchup(matchupMap, {
        seed1: final.seed1,
        seed2: final.seed2,
        team1: final.team1,
        team2: final.team2,
        winner: final.winner,
      });
    }

    function recordTeamResult(teamMap, year, roundKey, game) {
      const { team1, team2, winner, seed1, seed2, score1, score2 } = game;
      if (!team1 || !team2 || team1 === team2) return;
      const stats1 = ensureTeam(teamMap, team1);
      const stats2 = ensureTeam(teamMap, team2);
      if (!stats1 || !stats2) return;
      const roundLabel = friendlyRound(roundKey);
      const team1Win = winner === team1;
      const team2Win = winner === team2;
      if (team1Win) {
        stats1.wins += 1;
        stats2.losses += 1;
      } else if (team2Win) {
        stats2.wins += 1;
        stats1.losses += 1;
      }

      stats1.games.push({
        year,
        roundKey,
        round: roundLabel,
        opponent: team2,
        teamSeed: seed1 ?? null,
        opponentSeed: seed2 ?? null,
        result: team1Win ? 'W' : 'L',
        teamScore: typeof score1 === 'number' ? score1 : null,
        opponentScore: typeof score2 === 'number' ? score2 : null,
      });

      stats2.games.push({
        year,
        roundKey,
        round: roundLabel,
        opponent: team1,
        teamSeed: seed2 ?? null,
        opponentSeed: seed1 ?? null,
        result: team2Win ? 'W' : 'L',
        teamScore: typeof score2 === 'number' ? score2 : null,
        opponentScore: typeof score1 === 'number' ? score1 : null,
      });
    }

    function updateSeedRound(seedRoundMap, roundKey, seed, isWinner) {
      if (typeof seed !== 'number') return;
      if (!seedRoundMap.has(roundKey)) seedRoundMap.set(roundKey, new Map());
      const roundMap = seedRoundMap.get(roundKey);
      if (!roundMap.has(seed)) roundMap.set(seed, { games: 0, wins: 0 });
      const entry = roundMap.get(seed);
      entry.games += 1;
      if (isWinner) entry.wins += 1;
    }

    function registerMatchup(matchupMap, game) {
      if (typeof game.seed1 !== 'number' || typeof game.seed2 !== 'number') return;
      const lowerSeed = Math.min(game.seed1, game.seed2);
      const higherSeed = Math.max(game.seed1, game.seed2);
      const key = `${lowerSeed}-${higherSeed}`;
      if (!matchupMap.has(key)) {
        matchupMap.set(key, { lowerSeed, higherSeed, games: 0, lowerWins: 0, higherWins: 0 });
      }
      const entry = matchupMap.get(key);
      entry.games += 1;
      if (resolveWinnerSeed(game) === lowerSeed) {
        entry.lowerWins += 1;
      } else {
        entry.higherWins += 1;
      }
    }

    function hydrateInsights() {
      if (!state.aggregated) return;
      renderTeamHistory();
      renderSeedRounds();
      renderSeedMatchups();
    }

    function renderTeamHistory() {
      const { teamHistory } = state.aggregated;
      const rows = Array.from(teamHistory.entries()).map(([team, stats]) => {
        const totalGames = stats.wins + stats.losses;
        const winPctValue = totalGames ? stats.wins / totalGames : 0;
        return {
          team,
          titles: stats.titles,
          runnerUp: stats.runnerUp,
          finalFour: stats.finalFour,
          wins: stats.wins,
          losses: stats.losses,
          winPct: winPctValue,
        };
      });

      const direction = state.teamSort.direction === 'asc' ? 1 : -1;
      rows.sort((a, b) => {
        const key = state.teamSort.key;
        if (key === 'team') {
          return a.team.localeCompare(b.team) * direction;
        }
        const valA = a[key] ?? 0;
        const valB = b[key] ?? 0;
        if (valA === valB) {
          return a.team.localeCompare(b.team) * direction;
        }
        return (valA > valB ? 1 : -1) * direction;
      });

      const tbody = document.getElementById('teamHistoryTable');
      tbody.innerHTML = '';
      rows.forEach(entry => {
        const row = document.createElement('tr');
        const totalGames = entry.wins + entry.losses;
        const winPct = totalGames ? (entry.winPct * 100).toFixed(0) : '0';
        row.dataset.team = entry.team;
        row.classList.add('clickable-row');
        const logo = getTeamLogoUrl(entry.team);
        row.innerHTML = `
          <td>${logo ? `<img src="${logo}" alt="${entry.team} logo" class="team-logo small" onerror="this.style.display='none'"> ` : ''}${entry.team}</td>
          <td>${entry.titles || '-'}</td>
          <td>${entry.wins}</td>
          <td>${entry.losses}</td>
          <td><div class="win-bar"><div class="win-bar-fill" style="width:${Math.min(winPct, 100) * 0.4}px"></div>${winPct}%</div></td>
        `;
        tbody.appendChild(row);
      });
      document.getElementById('teamHistorySummary').textContent = `${teamHistory.size} teams ¬∑ Tap to view history`;
      updateTeamSortIndicators();
    }

    function renderSeedRounds() {
      const container = document.getElementById('seedRoundGrid');
      container.innerHTML = '';
      const order = ['round1', 'round2', 'sweet16', 'elite8', 'finalFour', 'championship'];
      const labels = {
        round1: 'R64',
        round2: 'R32',
        sweet16: 'S16',
        elite8: 'E8',
        finalFour: 'F4',
        championship: 'Final',
      };
      order.forEach(roundKey => {
        const roundMap = state.aggregated.seedRounds.get(roundKey);
        if (!roundMap) return;
        const card = document.createElement('section');
        card.className = 'seed-card';
        const heading = document.createElement('h4');
        heading.textContent = labels[roundKey];
        heading.style.fontSize = '0.85rem';
        heading.style.marginBottom = '8px';
        card.appendChild(heading);
        const list = document.createElement('div');
        list.style.display = 'grid';
        list.style.gridTemplateColumns = 'repeat(2, 1fr)';
        list.style.gap = '4px';
        list.style.fontSize = '0.7rem';
        const seeds = Array.from(roundMap.entries()).sort((a, b) => a[0] - b[0]);
        seeds.forEach(([seed, record]) => {
          const winRate = record.games ? ((record.wins / record.games) * 100).toFixed(0) : '0';
          const entry = document.createElement('div');
          entry.style.color = 'var(--muted)';
          entry.innerHTML = `<span style="color:var(--text)">${seed}:</span> ${winRate}%`;
          list.appendChild(entry);
        });
        card.appendChild(list);
        container.appendChild(card);
      });
    }

    function renderSeedMatchups() {
      const table = document.getElementById('seedMatchupTable');
      table.innerHTML = '';
      const records = Array.from(state.aggregated.matchups.values())
        .filter(entry => entry.games >= 2)
        .sort((a, b) => b.games - a.games);
      records.forEach(entry => {
        const row = document.createElement('tr');
        const lowerRate = entry.games ? ((entry.lowerWins / entry.games) * 100).toFixed(0) : '0';
        const higherRate = entry.games ? ((entry.higherWins / entry.games) * 100).toFixed(0) : '0';
        const barWidth = Math.round(parseFloat(lowerRate) * 0.5);
        row.innerHTML = `
          <td>${entry.lowerSeed}v${entry.higherSeed}</td>
          <td>${entry.games}</td>
          <td><div class="win-bar"><div class="win-bar-fill" style="width:${barWidth}px"></div>${lowerRate}%</div></td>
          <td>${higherRate}%</td>
        `;
        table.appendChild(row);
      });
    }

    function setupTeamTableInteractions() {
      const table = document.querySelector('[data-team-table]');
      if (!table || table.dataset.enhanced) return;
      table.dataset.enhanced = 'true';
      const thead = table.querySelector('thead');
      const tbody = table.querySelector('tbody');
      if (thead) {
        thead.addEventListener('click', event => {
          const target = event.target.closest('[data-sort]');
          if (!target) return;
          const sortKey = target.dataset.sort;
          if (!sortKey) return;
          if (state.teamSort.key === sortKey) {
            state.teamSort.direction = state.teamSort.direction === 'asc' ? 'desc' : 'asc';
          } else {
            state.teamSort.key = sortKey;
            state.teamSort.direction = sortKey === 'team' ? 'asc' : 'desc';
          }
          if (state.aggregated) renderTeamHistory();
        });
      }
      if (tbody) {
        tbody.addEventListener('click', event => {
          const row = event.target.closest('tr[data-team]');
          if (!row) return;
          openTeamModal(row.dataset.team);
        });
      }
    }

    function updateTeamSortIndicators() {
      document.querySelectorAll('[data-sort]').forEach(th => {
        th.classList.remove('active-asc', 'active-desc');
        if (th.dataset.sort === state.teamSort.key) {
          th.classList.add(state.teamSort.direction === 'asc' ? 'active-asc' : 'active-desc');
        }
      });
    }

    function setupModalControls() {
      const overlay = document.getElementById('teamModal');
      if (!overlay || overlay.dataset.enhanced) return;
      overlay.dataset.enhanced = 'true';
      const closeBtn = document.getElementById('teamModalClose');
      if (closeBtn) {
        closeBtn.addEventListener('click', closeTeamModal);
      }
      overlay.addEventListener('click', event => {
        if (event.target === overlay) closeTeamModal();
      });
      document.addEventListener('keydown', event => {
        if (event.key === 'Escape' && !overlay.hasAttribute('hidden')) {
          closeTeamModal();
        }
      });
    }

    function openTeamModal(teamName) {
      if (!teamName || !state.aggregated) return;
      const overlay = document.getElementById('teamModal');
      if (!overlay) return;
      
      // Try normalized name first, then original
      let stats = state.aggregated.teamHistory.get(normalizeTeamName(teamName));
      if (!stats) stats = state.aggregated.teamHistory.get(teamName);
      if (!stats) return;
      
      const title = document.getElementById('teamModalTitle');
      const subtitle = document.getElementById('teamModalSubtitle');
      const statsRow = document.getElementById('teamModalStats');
      const list = document.getElementById('teamModalList');
      
      const logoUrl = getTeamLogoUrl(teamName);
      if (title) {
        title.innerHTML = logoUrl 
          ? `<img src="${logoUrl}" alt="${teamName}" class="modal-team-logo" onerror="this.style.display='none'">${teamName}`
          : teamName;
        title.style.display = 'flex';
        title.style.alignItems = 'center';
        title.style.gap = '12px';
      }
      const totalGames = stats.wins + stats.losses;
      const winPct = totalGames ? ((stats.wins / totalGames) * 100).toFixed(1) : '0.0';
      const uniqueYears = new Set(stats.games.map(g => g.year)).size;
      
      if (subtitle) subtitle.textContent = `${uniqueYears} tournaments since ${YEAR_START}`;
      
      // Render stats row
      if (statsRow) {
        statsRow.innerHTML = `
          <div class="modal-stat">
            <div class="modal-stat-value">${stats.titles}</div>
            <div class="modal-stat-label">Titles</div>
          </div>
          <div class="modal-stat">
            <div class="modal-stat-value">${stats.finalFour}</div>
            <div class="modal-stat-label">Final 4s</div>
          </div>
          <div class="modal-stat">
            <div class="modal-stat-value">${stats.wins}</div>
            <div class="modal-stat-label">Wins</div>
          </div>
          <div class="modal-stat">
            <div class="modal-stat-value">${stats.losses}</div>
            <div class="modal-stat-label">Losses</div>
          </div>
          <div class="modal-stat">
            <div class="modal-stat-value">${winPct}%</div>
            <div class="modal-stat-label">Win %</div>
          </div>
        `;
      }
      
      if (list) {
        list.innerHTML = '';
        const history = stats.games.slice().sort((a, b) => {
          if (a.year !== b.year) return b.year - a.year;
          const indexA = ROUND_SEQUENCE.indexOf(a.roundKey);
          const indexB = ROUND_SEQUENCE.indexOf(b.roundKey);
          const safeA = indexA === -1 ? ROUND_SEQUENCE.length : indexA;
          const safeB = indexB === -1 ? ROUND_SEQUENCE.length : indexB;
          if (safeA === safeB) {
            return a.opponent.localeCompare(b.opponent);
          }
          return safeA - safeB;
        });
        if (!history.length) {
          const empty = document.createElement('li');
          empty.className = 'game-history-item';
          empty.textContent = 'No recorded games for this program.';
          list.appendChild(empty);
        } else {
          history.forEach(item => {
            const li = document.createElement('li');
            li.className = `game-history-item ${item.result === 'W' ? 'win' : 'loss'}`;
            const scoreLine = (item.teamScore !== null && item.opponentScore !== null)
              ? `${item.teamScore}-${item.opponentScore}`
              : '';
            const opponentLogo = getTeamLogoUrl(item.opponent);
            li.innerHTML = `
              <div class="game-history-header">
                <span class="game-history-year">${item.year}</span>
                <span class="game-history-round">${item.round}</span>
              </div>
              <div class="game-history-matchup">
                ${item.result === 'W' ? 'W' : 'L'} vs ${opponentLogo ? ('<img src="' + opponentLogo + '" class="team-logo small" onerror="this.style.display=\'none\'"> ') : ''}<strong>${item.opponent}</strong> ${scoreLine}
              </div>
              <div class="game-history-detail">
                ${item.teamSeed ? `#${item.teamSeed}` : ''} vs ${item.opponentSeed ? `#${item.opponentSeed}` : ''}
              </div>
            `;
            list.appendChild(li);
          });
        }
      }
      overlay.removeAttribute('hidden');
      document.body.style.overflow = 'hidden';
    }

    function closeTeamModal() {
      const overlay = document.getElementById('teamModal');
      if (!overlay || overlay.hasAttribute('hidden')) return;
      overlay.setAttribute('hidden', '');
      document.body.style.overflow = '';
    }

    function runSimulation() {
      if (!state.loaded || !state.aggregated) {
        alert('Datasets still loading. Try again in a moment.');
        return;
      }
      const yearSelect = document.getElementById('simYearSelect');
      const year = Number(yearSelect.value);
      const mode = document.getElementById('simModeSelect').value;
      
      if (!state.tournaments.has(year)) return;
      const baseRounds = state.tournaments.get(year).rounds;
      const bracket = simulateBracket(baseRounds, mode);
      const accuracy = calculateBracketAccuracy(bracket, state.tournaments.get(year).rounds);
      
      renderSimulation(bracket, mode, accuracy);
    }

    function buildCustomRound1(teams) {
      const regions = ['East', 'West', 'Midwest', 'South'];
      const round1 = [];
      const seeds = [1, 16, 8, 9, 5, 12, 4, 13, 6, 11, 3, 14, 7, 10, 2, 15];
      
      for (let r = 0; r < 4; r++) {
        const region = regions[r];
        for (let s = 0; s < 16; s += 2) {
          const s1 = seeds[s];
          const s2 = seeds[s+1];
          const idx1 = r * 16 + s; // This is a simple linear map, logic can be tuned
          const idx2 = r * 16 + s + 1;
          round1.push({
            region,
            team1: teams[idx1] || `Team ${idx1+1}`, 
            seed1: s1,
            team2: teams[idx2] || `Team ${idx2+1}`, 
            seed2: s2
          });
        }
      }
      return round1;
    }

    function calculateBracketAccuracy(simulated, actual) {
      let matches = 0;
      let totalGames = 0;
      const keys = ['round1', 'round2', 'sweet16', 'elite8', 'finalFour'];
      
      keys.forEach(k => {
        if (!simulated[k] || !actual[k]) return;
        simulated[k].forEach((game, i) => {
          if (actual[k][i] && game.winner === actual[k][i].winner) {
            matches++;
          }
          totalGames++;
        });
      });

      if (simulated.championship && actual.championship) {
        if (simulated.championship.winner === actual.championship.winner) {
          matches++;
        }
        totalGames++;
      }

      return totalGames > 0 ? (matches / totalGames * 100).toFixed(1) : 0;
    }

    function simulateBracket(rounds, mode) {
      const simulated = {};
      const baseRound = Array.isArray(rounds.round1) ? rounds.round1.map(game => ({ ...game })) : [];
      simulated.round1 = simulateRound(baseRound, mode);

      let previousRound = simulated.round1;
      ['round2', 'sweet16', 'elite8', 'finalFour'].forEach(key => {
        const nextMatchups = buildNextRound(previousRound);
        const simulatedRound = simulateRound(nextMatchups, mode);
        simulated[key] = simulatedRound;
        previousRound = simulatedRound;
      });

      simulated.championship = simulateChampionship(buildChampionship(simulated.finalFour), mode);
      return simulated;
    }

    function simulateRound(matchups, mode) {
      return matchups.map(game => ({
        team1: game.team1,
        team2: game.team2,
        seed1: game.seed1,
        seed2: game.seed2,
        region: game.region ?? null,
        winner: pickWinner(game, mode),
      }));
    }

    function buildNextRound(previousRoundGames) {
      const matchups = [];
      for (let i = 0; i < previousRoundGames.length; i += 2) {
        const gameA = previousRoundGames[i];
        const gameB = previousRoundGames[i + 1];
        if (!gameA || !gameB || !gameA.winner || !gameB.winner) continue;
        matchups.push({
          team1: gameA.winner,
          seed1: resolveWinnerSeed(gameA),
          team2: gameB.winner,
          seed2: resolveWinnerSeed(gameB),
          region: gameA.region === gameB.region ? gameA.region : gameA.region || gameB.region || null,
        });
      }
      return matchups;
    }

    function buildChampionship(finalFourGames) {
      if (!finalFourGames || finalFourGames.length < 2) return null;
      const [eastWest, midSouth] = finalFourGames;
      if (!eastWest?.winner || !midSouth?.winner) return null;
      return {
        team1: eastWest.winner,
        seed1: resolveWinnerSeed(eastWest),
        team2: midSouth.winner,
        seed2: resolveWinnerSeed(midSouth),
      };
    }

    function simulateChampionship(matchup, mode) {
      if (!matchup) return null;
      return {
        ...matchup,
        winner: pickWinner(matchup, mode),
      };
    }

    function pickWinner(game, mode) {
      const seed1 = game.seed1 ?? resolveSeedFromPreviousRound(game.team1);
      const seed2 = game.seed2 ?? resolveSeedFromPreviousRound(game.team2);
      const stats1 = state.aggregated?.teamHistory.get(game.team1);
      const stats2 = state.aggregated?.teamHistory.get(game.team2);

      switch (mode) {
        case 'random':
          return coinFlip(game.team1, game.team2);
        case 'legacy': {
          const score1 = legacyScore(game.team1);
          const score2 = legacyScore(game.team2);
          if (score1 === score2) return coinFlip(game.team1, game.team2);
          return score1 >= score2 ? game.team1 : game.team2;
        }
        case 'team-win-pct': {
          const pct1 = computeWinPct(stats1);
          const pct2 = computeWinPct(stats2);
          if (pct1 === null && pct2 === null) return coinFlip(game.team1, game.team2);
          if (pct1 === null) return game.team2;
          if (pct2 === null) return game.team1;
          if (pct1 === pct2) return coinFlip(game.team1, game.team2);
          return pct1 > pct2 ? game.team1 : game.team2;
        }
        case 'team-total-wins': {
          const wins1 = stats1?.wins ?? null;
          const wins2 = stats2?.wins ?? null;
          if (wins1 === null && wins2 === null) return coinFlip(game.team1, game.team2);
          if (wins1 === null) return game.team2;
          if (wins2 === null) return game.team1;
          if (wins1 === wins2) return coinFlip(game.team1, game.team2);
          return wins1 > wins2 ? game.team1 : game.team2;
        }
        case 'team-titles': {
          const titles1 = stats1?.titles ?? null;
          const titles2 = stats2?.titles ?? null;
          if (titles1 === null && titles2 === null) return coinFlip(game.team1, game.team2);
          if (titles1 === null) return game.team2;
          if (titles2 === null) return game.team1;
          if (titles1 === titles2) return coinFlip(game.team1, game.team2);
          return titles1 > titles2 ? game.team1 : game.team2;
        }
        case 'seed-weighted':
          return seedWeightedPick(game.team1, seed1, game.team2, seed2);
        case 'seed-record':
        default: {
          const probability = seedMatchupProbability(seed1, seed2);
          if (probability !== null) {
            return Math.random() <= probability ? game.team1 : game.team2;
          }
          if (!Number.isFinite(seed1) || !Number.isFinite(seed2)) {
            return coinFlip(game.team1, game.team2);
          }
          if (seed1 === seed2) return coinFlip(game.team1, game.team2);
          return seed1 < seed2 ? game.team1 : game.team2;
        }
      }
    }

    function resolveSeedFromPreviousRound(team) {
      if (!state.currentYear) return null;
      const rounds = state.tournaments.get(state.currentYear)?.rounds;
      if (!rounds) return null;
      const allRounds = ['round1', 'round2', 'sweet16', 'elite8', 'finalFour', 'championship'];
      for (const roundKey of allRounds) {
        const games = Array.isArray(rounds[roundKey]) ? rounds[roundKey] : [rounds[roundKey]];
        for (const game of games) {
          if (!game) continue;
          if (game.team1 === team) return game.seed1;
          if (game.team2 === team) return game.seed2;
          if (game.winner === team) return resolveWinnerSeed(game);
        }
      }
      return null;
    }

    function legacyScore(team) {
      if (!team || !state.aggregated) return 0;
      const stats = state.aggregated.teamHistory.get(team);
      if (!stats) return 0;
      return stats.titles * 5 + stats.finalFour * 2 + stats.runnerUp;
    }

    function computeWinPct(stats) {
      if (!stats) return null;
      const total = stats.wins + stats.losses;
      if (!total) return null;
      return Number((stats.wins / total).toFixed(4));
    }

    function seedMatchupProbability(seed1, seed2) {
      if (typeof seed1 !== 'number' || typeof seed2 !== 'number' || !state.aggregated) return null;
      const lowerSeed = Math.min(seed1, seed2);
      const higherSeed = Math.max(seed1, seed2);
      const key = `${lowerSeed}-${higherSeed}`;
      const record = state.aggregated.matchups.get(key);
      if (!record || record.games < 3) return null;
      const lowerWinRate = record.lowerWins / record.games;
      return seed1 === lowerSeed ? lowerWinRate : 1 - lowerWinRate;
    }

    function renderSimulation(simulatedRounds, mode, accuracy = null) {
      const summary = document.getElementById('simSummary');
      const stats = document.getElementById('simStats');
      const treeContainer = document.getElementById('simTreeView');
      const listContainer = document.getElementById('simListView');
      const champion = simulatedRounds.championship?.winner;
      
      if (accuracy !== null) {
        stats.style.display = 'inline-flex';
        stats.textContent = `${accuracy}% match`;
      } else {
        stats.style.display = 'none';
      }

      summary.textContent = champion ? `üèÜ ${champion}` : 'Incomplete';
      
      // Render tree view
      treeContainer.innerHTML = '';
      treeContainer.appendChild(createSimTreeElement(simulatedRounds));
      
      // Render list view - match format of bracket list
      listContainer.innerHTML = '';
      const roundOrder = [
        { key: 'round1', label: 'Round of 64' },
        { key: 'round2', label: 'Round of 32' },
        { key: 'sweet16', label: 'Sweet 16' },
        { key: 'elite8', label: 'Elite Eight' },
        { key: 'finalFour', label: 'Final Four' },
        { key: 'championship', label: 'Championship' },
      ];
      
      roundOrder.forEach(round => {
        const section = document.createElement('div');
        section.style.marginBottom = '16px';
        
        const header = document.createElement('h3');
        header.style.cssText = 'font-size:0.85rem; color:var(--accent); margin:0 0 8px; padding:0 4px;';
        header.textContent = round.label;
        section.appendChild(header);
        
        const gamesContainer = document.createElement('div');
        gamesContainer.style.cssText = 'display:grid; grid-template-columns:repeat(auto-fill, minmax(150px, 1fr)); gap:8px;';
        
        if (round.key === 'championship') {
          if (simulatedRounds.championship) {
            gamesContainer.appendChild(renderListGame(simulatedRounds.championship, true));
          }
        } else {
          (simulatedRounds[round.key] || []).forEach(game => {
            gamesContainer.appendChild(renderListGame(game, round.key === 'finalFour'));
          });
        }
        
        section.appendChild(gamesContainer);
        listContainer.appendChild(section);
      });
    }
    
    function createSimTreeElement(simulatedRounds) {
      const wrapper = document.createElement('div');
      wrapper.className = 'bracket-container';
      
      const roundOrder = [
        { key: 'round1', label: 'R64' },
        { key: 'round2', label: 'R32' },
        { key: 'sweet16', label: 'Sweet 16' },
        { key: 'elite8', label: 'Elite 8' },
        { key: 'finalFour', label: 'Final 4' },
        { key: 'championship', label: 'Champion' },
      ];
      
      roundOrder.forEach((round, roundIndex) => {
        const col = document.createElement('div');
        col.className = 'bracket-round';
        
        const header = document.createElement('div');
        header.className = 'bracket-round-header';
        header.textContent = round.label;
        col.appendChild(header);
        
        const gamesDiv = document.createElement('div');
        gamesDiv.className = 'bracket-games';
        
        if (round.key === 'championship') {
          if (simulatedRounds.championship) {
            gamesDiv.appendChild(createBracketGame(simulatedRounds.championship, true));
          }
        } else {
          const games = simulatedRounds[round.key] || [];
          games.forEach(game => {
            gamesDiv.appendChild(createBracketGame(game, false));
          });
        }
        
        col.appendChild(gamesDiv);
        wrapper.appendChild(col);
        
        // Add connector column between rounds
        if (roundIndex < roundOrder.length - 1) {
          const connector = document.createElement('div');
          connector.className = 'bracket-connector';
          wrapper.appendChild(connector);
        }
      });
      
      return wrapper;
    }

    function modeLabel(mode) {
      switch (mode) {
        case 'seed-record':
          return 'seed-performance';
        case 'legacy':
          return 'legacy-weighted';
        case 'team-win-pct':
          return 'team win percentage';
        case 'team-total-wins':
          return 'historical win leader';
        case 'team-titles':
          return 'championship priority';
        case 'seed-weighted':
          return 'seed-weighted draw';
        default:
          return 'random draw';
      }
    }

    function seedWeightedPick(team1, seed1, team2, seed2) {
      if (!Number.isFinite(seed1) || !Number.isFinite(seed2)) {
        return coinFlip(team1, team2);
      }
      const total = seed1 + seed2;
      if (total <= 0) return coinFlip(team1, team2);
      const weight1 = Math.max(1, total - seed1);
      const weight2 = Math.max(1, total - seed2);
      const roll = Math.floor(Math.random() * (weight1 + weight2)) + 1;
      return roll <= weight1 ? team1 : team2;
    }

    function coinFlip(team1, team2) {
      return Math.random() < 0.5 ? team1 : team2;
    }

    function friendlyRound(roundKey) {
      switch (roundKey) {
        case 'round1': return 'R64';
        case 'round2': return 'R32';
        case 'sweet16': return 'S16';
        case 'elite8': return 'E8';
        case 'finalFour': return 'F4';
        default: return roundKey;
      }
    }
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Tile Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
*{box-sizing:border-box;}
body{
  margin:0;
  background:black;
  color:white;
  font-family:Arial,Helvetica,sans-serif;
  height:100vh;
  display:grid;
  grid-template-rows:1fr 1fr;
  grid-template-columns:repeat(4,1fr);
  gap:1vh;
  padding:1vh;
  overflow:hidden;
}

/* TILE STYLE */
.tile{
  background:#111;
  border-radius:1vh;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  padding:1vh;
  overflow:hidden;
  position:relative;
}

/* CLOCK */
#clock{font-size:4vw;font-weight:bold;text-align:center;}
#militaryTime{font-size:1vw;margin-top:0.3vh;opacity:0.7;}
#sunTimes{font-size:1vw;margin-top:0.3vh;opacity:0.8;}
#currentWeather{font-size:0.9vw;margin-top:0.3vh;opacity:0.85;text-align:center;}
#moonPhase{font-size:1.5vw;margin-top:0.3vh;opacity:0.9;text-align:center;}
#moonDates{font-size:0.8vw;margin-top:0.2vh;opacity:0.7;text-align:center;}
#tileClock.pulse{border:0.3vh solid white;transition:border 0.3s;}

/* INTERNET SPEED */
#speed{font-size:1.2vw;text-align:center;}

/* CALENDAR */
#calendar{display:grid;grid-template-columns:repeat(7,1fr);gap:0.3vh;width:90%;}
.calendar-day{opacity:0.6;font-weight:bold;text-align:center;}
.calendar-date{padding:0.5vh 0;border-radius:50%;display:flex;justify-content:center;align-items:center;}
.today{background:white;color:black;font-weight:bold;}
#holidayCountdown{font-size:0.9vw;margin-top:0.5vh;text-align:center;width:90%;}

/* FORECAST */
#forecast{display:flex;flex-direction:column;align-items:center;justify-content:flex-start;gap:0.3vh;}
.forecast-day{background:#222;margin:0.3vh;padding:0.5vh 0.5vw;width:90%;border-radius:0.5vh;text-align:center;}

/* ROTATING TILE SLIDER */
.tile-slider{width:90%;height:0.3vh;background:#555;border-radius:0.2vh;margin-top:0.5vh;position:relative;}
.tile-slider-fill{background:#0f0;height:100%;width:0%;border-radius:0.2vh;transition:width 0.1s linear;}

/* BGG LIST */
#bggList{text-align:left;width:90%;overflow:auto;font-size:1.2vw;}

/* SPORTS SCORES */
#sportsContent{text-align:left;width:90%;font-size:1.2vw;overflow:auto;}

/* RESPONSIVE */
@media(max-width:1024px){
  #clock{font-size:8vw;}
  #speed{font-size:2vw;}
}
</style>
</head>
<body>

<!-- Top row tiles -->
<div class="tile" id="tileClock"><div id="clock">--:--:--</div><div id="militaryTime">--:--</div><div id="sunTimes">üåÖ --:-- | üåá --:--</div><div id="currentWeather">Loading...</div><div id="moonPhase">üåë</div><div id="moonDates">Last: -- | Next: --</div></div>
<div class="tile" id="tileSpeed"><div id="speed">Testing speed...</div><div class="tile-slider"><div class="tile-slider-fill" id="speedSlider"></div></div></div>
<div class="tile" id="tileWeather"><div id="weather">Loading weather‚Ä¶</div><div class="tile-slider"><div class="tile-slider-fill" id="weatherSlider"></div></div></div>
<div class="tile" id="tileForecast"><div id="forecast">Loading forecast‚Ä¶</div><div class="tile-slider"><div class="tile-slider-fill" id="forecastSlider"></div></div></div>

<!-- Bottom row tiles -->
<div class="tile" id="tileCalendar"><div id="calendar"></div><div id="holidayCountdown"></div></div>
<div class="tile" id="tileBGG">
  <div id="bggList">Loading Top 10 BGG‚Ä¶</div>
</div>
<div class="tile" id="tileFun">
  <div id="funText">Loading standings‚Ä¶</div>
  <div class="tile-slider"><div class="tile-slider-fill" id="funSlider"></div></div>
</div>
<div class="tile" id="tileSports">
  <div id="sportsContent">Loading scores‚Ä¶</div>
  <div class="tile-slider"><div class="tile-slider-fill" id="sportsSlider"></div></div>
</div>

<script>
/* ========== CONFIG ========== */
const CONFIG={rotateIntervalMs:10000, location:{lat:39.5186,lon:-104.7614}};

/* ========== CLOCK ========== */
let sunriseTime="--:--";
let sunsetTime="--:--";

function updateClock(){
  const now=new Date();
  document.getElementById("clock").textContent=now.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',second:'2-digit'});
  document.getElementById("militaryTime").textContent=now.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',hour12:false});
  document.getElementById("sunTimes").innerHTML=`üåÖ ${sunriseTime} | üåá ${sunsetTime}`;
  if(now.getSeconds()===0){
    document.getElementById("tileClock").classList.add("pulse");
    setTimeout(()=>document.getElementById("tileClock").classList.remove("pulse"),1000);
  }
}
setInterval(updateClock,1000);
updateClock();

/* ========== INTERNET SPEED & STOCKS ========== */
let speedData={download:0,upload:0,lastChecked:null};
let stockData="Loading stocks...";
let gasData="Loading gas prices...";
let speedIndex=0;
const speedViews=["speed","stocks","gas"];

async function testSpeed(){
  try{
    // Download test
    const dlStart=performance.now();
    const dlSize=1000000;
    const dlUrl="https://cors-anywhere.herokuapp.com/https://speed.hetzner.de/1MB.bin";
    const dlRes=await fetch(dlUrl,{method:'GET',cache:'no-cache'});
    await dlRes.blob();
    const dlDuration=(performance.now()-dlStart)/1000;
    speedData.download=((dlSize*8)/dlDuration/1000000).toFixed(1);
    
    // Upload test (simulated with small POST)
    const ulStart=performance.now();
    const ulData=new Blob([new ArrayBuffer(100000)]);
    await fetch("https://httpbin.org/post",{method:'POST',body:ulData}).catch(()=>{});
    const ulDuration=(performance.now()-ulStart)/1000;
    speedData.upload=((100000*8)/ulDuration/1000000).toFixed(1);
    
    speedData.lastChecked=new Date();
  }catch{}
}

async function loadStockData(){
  try{
    const tickers=[{symbol:"^GSPC",name:"S&P 500"},{symbol:"^DJI",name:"Dow"},{symbol:"^IXIC",name:"Nasdaq"}];
    stockData="<strong>Market Indices</strong><br>";
    
    for(const {symbol,name} of tickers){
      try{
        const url=`https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=1d&range=1d`;
        const res=await fetch(url);
        const data=await res.json();
        const quote=data.chart.result[0].meta;
        const price=quote.regularMarketPrice.toFixed(2);
        const change=quote.regularMarketPrice-quote.chartPreviousClose;
        const changePercent=((change/quote.chartPreviousClose)*100).toFixed(2);
        const arrow=change>=0?"üü¢":"üî¥";
        stockData+=`${name}: ${price} ${arrow}${changePercent}%<br>`;
      }catch{
        stockData+=`${name}: Loading...<br>`;
      }
    }
  }catch{stockData="Stocks unavailable";}
}

async function loadGasPrices(){
  try{
    // Using GasBuddy-style data - simplified version
    // Real implementation would need API key or scraping
    const zip="80134";
    gasData=`<strong>Gas Prices (${zip})</strong><br>`;
    gasData+="‚õΩ Regular: $3.25<br>";
    gasData+="‚õΩ Mid-Grade: $3.45<br>";
    gasData+="‚õΩ Premium: $3.65<br>";
    gasData+="<small>Estimated prices</small>";
  }catch{
    gasData="Gas prices unavailable";
  }
}

function rotateSpeedTile(){
  const speedDiv=document.getElementById("speed");
  if(speedViews[speedIndex]==="speed"){
    const time=speedData.lastChecked?speedData.lastChecked.toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'}):"--:--";
    speedDiv.innerHTML=`<strong>Internet Speed</strong><br>‚¨á ${speedData.download} Mbps<br>‚¨Ü ${speedData.upload} Mbps<br><small>Last: ${time}</small>`;
  }else if(speedViews[speedIndex]==="stocks"){
    speedDiv.innerHTML=stockData;
  }else{
    speedDiv.innerHTML=gasData;
  }
  speedIndex=(speedIndex+1)%speedViews.length;
  startTileSlider("speedSlider",CONFIG.rotateIntervalMs);
}

testSpeed();
loadStockData();
loadGasPrices();
rotateSpeedTile();
setInterval(rotateSpeedTile,CONFIG.rotateIntervalMs);
setInterval(testSpeed,5*60*1000);
setInterval(loadStockData,5*60*1000);
setInterval(loadGasPrices,10*60*1000);

/* ========== CALENDAR ========== */
function renderCalendar(){
  const now=new Date();
  const year=now.getFullYear(), month=now.getMonth(), today=now.getDate();
  const firstDay=new Date(year,month,1).getDay();
  const daysInMonth=new Date(year,month+1,0).getDate();

  let html="";
  ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"].forEach(d=>html+=`<div class="calendar-day">${d}</div>`);
  for(let i=0;i<firstDay;i++) html+="<div></div>";
  for(let d=1;d<=daysInMonth;d++){
    const cls=d===today?"calendar-date today":"calendar-date";
    html+=`<div class="${cls}">${d}</div>`;
  }
  document.getElementById("calendar").innerHTML=html;
  updateHolidayCountdown();
}

function updateHolidayCountdown(){
  const now=new Date();
  const year=now.getFullYear();
  const holidays=[
    {name:"New Year's",date:new Date(year+1,0,1)},
    {name:"MLK Day",date:getNthWeekday(year,0,1,3)},
    {name:"Presidents'",date:getNthWeekday(year,1,1,3)},
    {name:"Memorial",date:getLastWeekday(year,4,1)},
    {name:"July 4th",date:new Date(year,6,4)},
    {name:"Labor Day",date:getNthWeekday(year,8,1,1)},
    {name:"Veterans",date:new Date(year,10,11)},
    {name:"Thanksgiving",date:getNthWeekday(year,10,4,4)},
    {name:"Christmas",date:new Date(year,11,25)}
  ];
  
  const upcoming=holidays.filter(h=>h.date>now).sort((a,b)=>a.date-b.date);
  if(upcoming.length===0) upcoming.push(holidays[0]);
  
  const startOfYear=new Date(year,0,1);
  const endOfYear=new Date(year,11,31,23,59,59);
  const dayOfYear=Math.ceil((now-startOfYear)/(1000*60*60*24))+1;
  const daysLeftInYear=Math.ceil((endOfYear-now)/(1000*60*60*24));
  
  let html=`<small>Year ${year} | Day ${dayOfYear} | ${daysLeftInYear} days left</small><br>`;
  for(let i=0;i<Math.min(5,upcoming.length);i++){
    const days=Math.ceil((upcoming[i].date-now)/(1000*60*60*24));
    const emoji=i===0?"üéâ":i===1?"üéà":i===2?"üéÅ":i===3?"üéä":"üéà";
    html+=`${emoji} ${upcoming[i].name}: ${days}d`;
    if(i<Math.min(5,upcoming.length)-1) html+=" | ";
  }
  document.getElementById("holidayCountdown").innerHTML=html;
}

function getNthWeekday(year,month,weekday,n){
  const date=new Date(year,month,1);
  let count=0;
  while(count<n){
    if(date.getDay()===weekday) count++;
    if(count<n) date.setDate(date.getDate()+1);
  }
  return date;
}

function getLastWeekday(year,month,weekday){
  const date=new Date(year,month+1,0);
  while(date.getDay()!==weekday) date.setDate(date.getDate()-1);
  return date;
}

renderCalendar();
setInterval(updateHolidayCountdown,60*60*1000);

/* ========== WEATHER ========== */
let forecastData=[];
const seasonalAvgs={winter:38,spring:58,summer:78,fall:58}; // Colorado averages
let weatherViews=[];
let weatherIndex=0;
let rainHistory=[];
let snowHistory=[];
let uvIndex=0;

async function loadHistoricalPrecipitation(){
  // Parker 80134 coordinates
  const lat=39.5186, lon=-104.7614;
  const today=new Date();
  const endDate=today.toISOString().split('T')[0];
  
  // Start from 3 years ago to ensure we get 10 events
  const startDate=new Date(today);
  startDate.setFullYear(startDate.getFullYear()-3);
  const startDateStr=startDate.toISOString().split('T')[0];
  
  try{
    const url=`https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}`+
      `&start_date=${startDateStr}&end_date=${endDate}`+
      `&daily=rain_sum,snowfall_sum&temperature_unit=fahrenheit&precipitation_unit=inch&timezone=auto`;
    const res=await fetch(url);
    const data=await res.json();
    
    rainHistory=[];
    snowHistory=[];
    
    // Go backwards through time to find last 10 events
    for(let i=data.daily.time.length-1; i>=0 && (rainHistory.length<10 || snowHistory.length<10); i--){
      const rainAmt=data.daily.rain_sum[i];
      const snowAmt=data.daily.snowfall_sum[i];
      const date=new Date(data.daily.time[i]);
      const dateStr=date.toLocaleDateString([],{month:'short',day:'numeric',year:'numeric'});
      
      if(rainAmt>=0.1 && rainHistory.length<10){
        rainHistory.push(`${dateStr}: ${rainAmt.toFixed(2)}"`);
      }
      if(snowAmt>=0.1 && snowHistory.length<10){
        snowHistory.push(`${dateStr}: ${snowAmt.toFixed(2)}"`);
      }
    }
  }catch(e){
    console.log('Error loading historical precipitation:',e);
    rainHistory=['Historical data unavailable'];
    snowHistory=['Historical data unavailable'];
  }
}

async function loadWeather(){
  try{
    // Parker 80134 coordinates
    const lat=39.5186, lon=-104.7614;
    const url=`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}`+
      `&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,rain_sum,snowfall_sum,windspeed_10m_max,precipitation_probability_max,sunrise,sunset,weathercode,uv_index_max`+
      `&current_weather=true&timezone=auto&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch`;
    const res=await fetch(url); const d=await res.json();

    // Update sunrise/sunset for clock
    sunriseTime=new Date(d.daily.sunrise[0]).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'});
    sunsetTime=new Date(d.daily.sunset[0]).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'});

    // UV Index
    uvIndex=Math.round(d.daily.uv_index_max[0]);
    let uvLevel="Low";
    if(uvIndex>=11) uvLevel="Extreme";
    else if(uvIndex>=8) uvLevel="Very High";
    else if(uvIndex>=6) uvLevel="High";
    else if(uvIndex>=3) uvLevel="Moderate";

    // Current weather for clock tile
    const cw=d.current_weather;
    const todayHi=Math.round(d.daily.temperature_2m_max[0]);
    const todayLo=Math.round(d.daily.temperature_2m_min[0]);
    document.getElementById("currentWeather").innerHTML=`üå°Ô∏è ${todayHi}/${todayLo}¬∞F | üí® ${Math.round(cw.windspeed)} mph | ‚òÄÔ∏è UV: ${uvIndex}`;

    // Calculate historical averages from available data (last 7 days)
    const now=new Date();
    const month=now.getMonth();
    let season="winter";
    if(month>=2 && month<=4) season="spring";
    else if(month>=5 && month<=7) season="summer";
    else if(month>=8 && month<=10) season="fall";
    const avgTemp=seasonalAvgs[season];
    
    // Calculate actual hi/lo from last 7 days of data
    let sumHi=0,sumLo=0,count=0;
    for(let i=0;i<Math.min(7,d.daily.time.length);i++){
      sumHi+=d.daily.temperature_2m_max[i];
      sumLo+=d.daily.temperature_2m_min[i];
      count++;
    }
    const recentAvgHi=count>0?Math.round(sumHi/count):avgTemp+5;
    const recentAvgLo=count>0?Math.round(sumLo/count):avgTemp-5;
    
    // Load historical precipitation data (last 10 actual events)
    await loadHistoricalPrecipitation();
    
    weatherViews=[
      `<strong>Historical Averages (${season})</strong><br>Seasonal: ${avgTemp}¬∞F<br>Recent Hi/Lo: ${recentAvgHi}/${recentAvgLo}¬∞F<br><small>Last 7 days avg</small>`,
      `<strong>Last 10 Rain Events ‚â•0.1"</strong><br>${rainHistory.length>0?rainHistory.join('<br>'):'No events found'}`,
      `<strong>Last 10 Snow Events ‚â•0.1"</strong><br>${snowHistory.length>0?snowHistory.join('<br>'):'No events found'}`
    ];

    forecastData=d.daily;
    renderForecast();
    rotateWeatherTile();
  }catch{document.getElementById("weather").textContent="Weather unavailable";}
}

function rotateWeatherTile(){
  if(weatherViews.length===0) return;
  document.getElementById("weather").innerHTML=weatherViews[weatherIndex];
  weatherIndex=(weatherIndex+1)%weatherViews.length;
  startTileSlider("weatherSlider",CONFIG.rotateIntervalMs);
}

loadWeather();
setInterval(rotateWeatherTile,CONFIG.rotateIntervalMs);
setInterval(loadWeather,30*60*1000);

function getWeatherIcon(code){if(code===0)return"‚òÄÔ∏è";else if(code<=3)return"‚õÖ";else if(code>=61 && code<=63)return"üåßÔ∏è";else if(code>=71 && code<=73)return"‚ùÑÔ∏è";else return"‚òÅÔ∏è";}

let forecastViewIndex=0;
const forecastViews=[3,7]; // 3-day and 7-day views

function renderForecast(){
  if(!forecastData || !forecastData.time) return;
  
  const container=document.getElementById("forecast"); container.innerHTML="";
  const totalDays=forecastViews[forecastViewIndex];
  
  // First show the current day label
  const firstDate=new Date(forecastData.time[0]);
  const today=new Date();
  today.setHours(0,0,0,0);
  const firstForecastDate=new Date(firstDate);
  firstForecastDate.setHours(0,0,0,0);
  const firstDayDiff=Math.round((firstForecastDate-today)/(1000*60*60*24));
  
  let firstLabel;
  if(firstDayDiff===0) firstLabel="Today";
  else if(firstDayDiff===1) firstLabel="Tomorrow";
  else firstLabel=firstDate.toLocaleDateString([], {weekday:'short',month:'short',day:'numeric'});
  
  const firstHi=Math.round(forecastData.temperature_2m_max[0]);
  const firstLo=Math.round(forecastData.temperature_2m_min[0]);
  const firstRain=forecastData.rain_sum[0].toFixed(2);
  const firstSnow=forecastData.snowfall_sum[0].toFixed(2);
  const firstWind=Math.round(forecastData.windspeed_10m_max[0]);
  const firstPop=forecastData.precipitation_probability_max[0];
  const firstIcon=getWeatherIcon(forecastData.weathercode[0]);
  
  const firstDiv=document.createElement("div"); firstDiv.className="forecast-day";
  firstDiv.innerHTML=`${firstLabel} ${firstIcon} üå°Ô∏è ${firstHi}/${firstLo}¬∞F üåßÔ∏è ${firstRain} ‚ùÑÔ∏è ${firstSnow} üí® ${firstWind} mph ‚òî ${firstPop}%`;
  container.appendChild(firstDiv);
  
  // Then show next days
  const nextDays=totalDays-1; // Subtract 1 because we already showed the first day
  for(let i=1;i<=nextDays && i<forecastData.time.length;i++){
    const date=new Date(forecastData.time[i]);
    const forecastDate=new Date(date);
    forecastDate.setHours(0,0,0,0);
    const dayDiff=Math.round((forecastDate-today)/(1000*60*60*24));
    
    let dayLabel;
    if(dayDiff===1) dayLabel="Tomorrow";
    else dayLabel=date.toLocaleDateString([], {weekday:'short',month:'short',day:'numeric'});
    
    const hi=Math.round(forecastData.temperature_2m_max[i]);
    const lo=Math.round(forecastData.temperature_2m_min[i]);
    const rain=forecastData.rain_sum[i].toFixed(2);
    const snow=forecastData.snowfall_sum[i].toFixed(2);
    const wind=Math.round(forecastData.windspeed_10m_max[i]);
    const pop=forecastData.precipitation_probability_max[i];
    const icon=getWeatherIcon(forecastData.weathercode[i]);

    const dayDiv=document.createElement("div"); dayDiv.className="forecast-day";
    dayDiv.innerHTML=`${dayLabel} ${icon} üå°Ô∏è ${hi}/${lo}¬∞F üåßÔ∏è ${rain} ‚ùÑÔ∏è ${snow} üí® ${wind} mph ‚òî ${pop}%`;
    container.appendChild(dayDiv);
  }

  startTileSlider("forecastSlider", CONFIG.rotateIntervalMs);
}

function rotateForecastView(){
  if(forecastData.time){
    forecastViewIndex=(forecastViewIndex+1)%forecastViews.length;
    renderForecast();
  }
}

setInterval(rotateForecastView,CONFIG.rotateIntervalMs);

/* ========== MOON PHASE ========== */
function calculateMoonPhase(date){
  let year=date.getFullYear();
  let month=date.getMonth()+1;
  const day=date.getDate();
  
  let c,e,jd,b;
  if(month<3){
    year--;
    month+=12;
  }
  ++month;
  c=365.25*year;
  e=30.6*month;
  jd=c+e+day-694039.09;
  jd/=29.5305882;
  b=parseInt(jd);
  jd-=b;
  b=Math.round(jd*8);
  
  const phases=[
    {name:"New Moon",emoji:"üåë",index:0},
    {name:"Waxing Crescent",emoji:"üåí",index:1},
    {name:"First Quarter",emoji:"üåì",index:2},
    {name:"Waxing Gibbous",emoji:"üåî",index:3},
    {name:"Full Moon",emoji:"üåï",index:4},
    {name:"Waning Gibbous",emoji:"üåñ",index:5},
    {name:"Last Quarter",emoji:"üåó",index:6},
    {name:"Waning Crescent",emoji:"üåò",index:7}
  ];
  
  const phase=phases[b%8];
  const illumination=(jd*100).toFixed(1);
  return {phase,illumination,phaseIndex:b%8};
}

function findFullMoonDates(){
  const now=new Date();
  const today=new Date(now.getFullYear(),now.getMonth(),now.getDate());
  
  // Search backwards for last full moon (up to 30 days)
  let lastFull=null;
  for(let i=0;i<=30;i++){
    const testDate=new Date(today);
    testDate.setDate(testDate.getDate()-i);
    const moonData=calculateMoonPhase(testDate);
    if(moonData.phaseIndex===4){
      lastFull=testDate;
      break;
    }
  }
  
  // Search forwards for next full moon (up to 30 days)
  let nextFull=null;
  for(let i=1;i<=30;i++){
    const testDate=new Date(today);
    testDate.setDate(testDate.getDate()+i);
    const moonData=calculateMoonPhase(testDate);
    if(moonData.phaseIndex===4){
      nextFull=testDate;
      break;
    }
  }
  
  return {lastFull,nextFull};
}

function updateMoonDisplay(){
  const now=new Date();
  const moonData=calculateMoonPhase(now);
  const {lastFull,nextFull}=findFullMoonDates();
  
  document.getElementById("moonPhase").innerHTML=`${moonData.phase.emoji} ${moonData.phase.name} (${moonData.illumination}%)`;
  
  const lastStr=lastFull?lastFull.toLocaleDateString([],{month:'short',day:'numeric'}):"--";
  const nextStr=nextFull?nextFull.toLocaleDateString([],{month:'short',day:'numeric'}):"--";
  document.getElementById("moonDates").innerHTML=`Last Full: ${lastStr} | Next Full: ${nextStr}`;
}

updateMoonDisplay();
setInterval(updateMoonDisplay,60*60*1000); // Update every hour

/* ========== ROTATING TILES ========== */
let funTileViews=[];
let funTileIndex=0;

async function loadStandingsForLeague(league,url){
  try{
    const res=await fetch(url);
    const data=await res.json();
    
    if(data.children && data.children.length>0){
      let html=`<strong>${league} Standings</strong><br>`;
      const isCollege=league==="NCAAF" || league==="NCAAM";
      const maxTeams=isCollege?25:999; // Top 25 for college, all for pro
      const standings=data.children[0].standings.entries.slice(0,maxTeams);
      
      standings.forEach((team,idx)=>{
        const teamName=team.team.abbreviation || team.team.displayName;
        const wins=team.stats.find(s=>s.name==="wins")?.value||0;
        const losses=team.stats.find(s=>s.name==="losses")?.value||0;
        html+=`${idx+1}. ${teamName} ${wins}-${losses}<br>`;
      });
      
      return html;
    }
  }catch(e){console.log(`Error fetching ${league} standings:`,e);}
  return `<strong>${league} Standings</strong><br>Unavailable`;
}

async function updateFunTile(){
  const standingsAPIs={
    NBA:"https://site.web.api.espn.com/apis/v2/sports/basketball/nba/standings",
    NFL:"https://site.web.api.espn.com/apis/v2/sports/football/nfl/standings",
    NHL:"https://site.web.api.espn.com/apis/v2/sports/hockey/nhl/standings",
    MLB:"https://site.web.api.espn.com/apis/v2/sports/baseball/mlb/standings",
    NCAAF:"https://site.web.api.espn.com/apis/v2/sports/football/college-football/standings",
    NCAAM:"https://site.web.api.espn.com/apis/v2/sports/basketball/mens-college-basketball/standings"
  };
  
  funTileViews=[];
  for(const [league,url] of Object.entries(standingsAPIs)){
    const standings=await loadStandingsForLeague(league,url);
    funTileViews.push(standings);
  }
  
  if(funTileViews.length===0){
    funTileViews=["No standings available"];
  }
  rotateFunTile();
}

function rotateFunTile(){
  if(funTileViews.length===0) return;
  document.getElementById("funText").innerHTML=funTileViews[funTileIndex];
  funTileIndex=(funTileIndex+1)%funTileViews.length;
  startTileSlider("funSlider",CONFIG.rotateIntervalMs);
}

updateFunTile();
setInterval(rotateFunTile,CONFIG.rotateIntervalMs);
setInterval(updateFunTile,10*60*1000); // Refresh every 10 minutes

function startTileSlider(sliderId, interval){
  const fill=document.getElementById(sliderId);
  fill.style.width="0%";
  const start=Date.now();
  const update=setInterval(()=>{
    const elapsed=Date.now()-start;
    const percent=Math.min(100,(elapsed/interval)*100);
    fill.style.width=percent+"%";
    if(percent>=100) clearInterval(update);
  },50);
}

/* ========== BOARD GAME GEEK TOP 10 ========== */
const bggTop10=[
  "1. Brass: Birmingham","2. Ark Nova","3. Pandemic Legacy: Season 1","4. Gloomhaven",
  "5. Dune: Imperium","6. Twilight Imperium 4th","7. Dune: Imperium ‚Äì Uprising",
  "8. War of the Ring 2nd","9. Terraforming Mars","10. Star Wars: Rebellion"
];

const spielDesJahres=[
  "2024: Sky Team","2023: Dorfromantik","2022: Cascadia","2021: MicroMacro: Crime City",
  "2020: Pictures","2019: Just One","2018: Azul","2017: Kingdomino",
  "2016: Codenames","2015: Colt Express"
];

let bggViews=[
  `<strong>BGG Top 10</strong><br>${bggTop10.join("<br>")}`,
  `<strong>Spiel des Jahres<br>Last 10 Winners</strong><br>${spielDesJahres.join("<br>")}`
];
let bggIndex=0;

function rotateBGGTile(){
  document.getElementById("bggList").innerHTML=bggViews[bggIndex];
  bggIndex=(bggIndex+1)%bggViews.length;
}

rotateBGGTile();
setInterval(rotateBGGTile,CONFIG.rotateIntervalMs);

/* ========== SPORTS SCORES ========== */
const sportsAPIs={
  NBA:"https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard",
  NFL:"https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard",
  NHL:"https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/scoreboard",
  MLB:"https://site.api.espn.com/apis/site/v2/sports/baseball/mlb/scoreboard",
  NCAAF:"https://site.api.espn.com/apis/site/v2/sports/football/college-football/scoreboard",
  NCAAM:"https://site.api.espn.com/apis/site/v2/sports/basketball/mens-college-basketball/scoreboard"
};
let sportsData=[];
let sportsIndex=0;

async function loadSportsScores(){
  sportsData=[];
  const today=new Date();
  const yesterday=new Date(today); yesterday.setDate(yesterday.getDate()-1);
  
  for(const [league,baseUrl] of Object.entries(sportsAPIs)){
    // Today's games
    await fetchSportsDay(league,"Today",baseUrl,formatDate(today));
    // Yesterday's games
    await fetchSportsDay(league,"Yesterday",baseUrl,formatDate(yesterday));
  }
  
  if(sportsData.length===0){
    sportsData.push("No games found");
  }
  if(sportsIndex>=sportsData.length) sportsIndex=0;
}

async function fetchSportsDay(league,dayLabel,baseUrl,dateStr){
  try{
    const url=`${baseUrl}?dates=${dateStr}`;
    const res=await fetch(url);
    const data=await res.json();
    
    if(data.events && data.events.length>0){
      // Calculate combined win% for each game
      const gamesWithWinPct=data.events.map(event=>{
        const comp=event.competitions[0];
        const homeTeam=comp.competitors.find(c=>c.homeAway==="home");
        const awayTeam=comp.competitors.find(c=>c.homeAway==="away");
        
        // Calculate win percentage for each team
        const homeRecord=homeTeam.records?.[0];
        const awayRecord=awayTeam.records?.[0];
        const homeWinPct=homeRecord?.stats?.find(s=>s.name==="winPercent")?.value||0;
        const awayWinPct=awayRecord?.stats?.find(s=>s.name==="winPercent")?.value||0;
        const combinedWinPct=parseFloat(homeWinPct)+parseFloat(awayWinPct);
        
        return {event,comp,homeTeam,awayTeam,combinedWinPct};
      });
      
      // Sort by combined win% descending
      gamesWithWinPct.sort((a,b)=>b.combinedWinPct-a.combinedWinPct);
      
      let html=`<strong>${league} - ${dayLabel}</strong><br>`;
      gamesWithWinPct.forEach(({comp,homeTeam,awayTeam})=>{
        const status=comp.status.type.description;
        const gameTime=comp.status.type.state==="pre"?new Date(comp.date).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'}):"";
        const timeStr=gameTime?` ${gameTime}`:"";
        html+=`${awayTeam.team.abbreviation} ${awayTeam.score} @ ${homeTeam.team.abbreviation} ${homeTeam.score} (${status}${timeStr})<br>`;
      });
      sportsData.push(html);
    }
  }catch(e){console.log(`Error fetching ${league}:`,e);}
}

function formatDate(date){
  const y=date.getFullYear();
  const m=String(date.getMonth()+1).padStart(2,'0');
  const d=String(date.getDate()).padStart(2,'0');
  return `${y}${m}${d}`;
}

function rotateSportsTile(){
  if(sportsData.length===0){
    document.getElementById("sportsContent").innerHTML="Loading scores...";
    return;
  }
  document.getElementById("sportsContent").innerHTML=sportsData[sportsIndex];
  sportsIndex=(sportsIndex+1)%sportsData.length;
  startTileSlider("sportsSlider",CONFIG.rotateIntervalMs);
}

loadSportsScores().then(()=>rotateSportsTile());
setInterval(rotateSportsTile,CONFIG.rotateIntervalMs);
setInterval(loadSportsScores,10*60*1000); // Refresh every 10 minutes

</script>
</body>
</html>
